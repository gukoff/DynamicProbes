<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.Linq" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool on and at:
//     <#= DateTimeOffset.Now.ToString("ddd, dd MMM yyyy HH:mm:ss zzz", CultureInfo.InvariantCulture) #>
//
//     Changes to this file will be lost if the code is re-generated.
// </auto-generated>
//------------------------------------------------------------------------------

#nullable enable // required for auto-generated sources (see below why)

// > Older code generation strategies may not be nullable aware. Setting the
// > project-level nullable context to "enable" could result in many
// > warnings that a user is unable to fix. To support this scenario any syntax
// > tree that is determined to be generated will have its nullable state
// > implicitly set to "disable", regardless of the overall project state.
//
// Source: https://github.com/dotnet/roslyn/blob/70e158ba6c2c99bd3c3fc0754af0dbf82a6d353d/docs/features/nullable-reference-types.md#generated-code

using static Libstapsdt.Libstapsdt;

namespace DynamicProbes;
<#
    const string indent1 = "    ";
    const string indent2 = indent1 + indent1;

    foreach (var ns in from count in Enumerable.Range(0, 7)
                       select Enumerable.Range(1, count).ToArray())
    {
        string[] typeParams = ns.Length switch
        {
            0 => [],
            1 => ["T"],
            _ => [..from n in ns select $"T{n}"],
        };

        string[] args = ns.Length switch
        {
            0 => [],
            1 => ["arg"],
            _ => [..from n in ns select $"arg{n}"],
        };

        var typeParamsList = typeParams.Length > 0
                           ? $"<{string.Join(", ", typeParams)}>"
                           : string.Empty;

        string Constraints(string none, Func<string, string> singleton, Func<IEnumerable<string>, string> many)
        {
            var result = typeParams switch
            {
                { Length: 0 } => none,
                { Length: 1 } ts => singleton(ts[0]),
                var ts => many(ts),
            };
            return result.Replace("\n", Environment.NewLine);
        };

        var genericName = $"Probe{typeParamsList}";
#>

partial record struct <#= genericName #><#=
    Constraints(string.Empty,
                t => $"\n{indent1}where {t} : IFireArgLong",
                ts => $"{string.Join(null, from t in ts select $"\n{indent1}where {t} : IFireArgLong")}") #>
{
    readonly Provider provider;
    readonly nint probe;

    internal Probe(Provider provider, string name, IntPtr probe)
    {
        this.provider = provider;
        Name = name;
        this.probe = probe;
    }

    public string Name { get; }

    bool IsProviderLoaded => this.provider.IsLoaded;

    public bool IsEnabled => IsProviderLoaded && ProbeIsEnabled(this.probe);

    public <#= genericName #>? Active => IsEnabled ? this : null;

    public void Fire(<#= string.Join(", ", typeParams.Zip(args, (type, arg) => $"{type} {arg}")) #>)
    {
        if (!IsProviderLoaded)
            return;
        ProbeFire(this.probe<#= string.Join(null, from arg in args select $", {arg}.UncheckedValue") #>);
    }

    public override string ToString() => $"{provider}:{Name}";
}

partial class Provider
{
    public <#= genericName #> AddProbe<#= typeParamsList #>(string name)<#=
        Constraints(string.Empty,
                    t => $"\n{indent2}where {t} : IArgType, IFireArgLong",
                    ts => string.Join(null, from t in ts select $"\n{indent2}where {t} : IArgType, IFireArgLong")) #>
    {
        var @this = This;
        return new(@this, name, Libstapsdt.Libstapsdt.ProviderAddProbe(@this, name<#= string.Join(null, from t in typeParams select $", (Libstapsdt.ArgType){t}.ArgType") #>));
    }
}
<#	} #>
